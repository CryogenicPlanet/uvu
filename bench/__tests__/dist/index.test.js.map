{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/dequal@1.0.1/node_modules/dequal/dist/dequal.js", "../../node_modules/.pnpm/kleur@4.1.4/node_modules/kleur/index.js", "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/src/diff/base.js", "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/src/diff/character.js", "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/src/util/params.js", "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/src/diff/word.js", "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/src/diff/line.js", "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/src/diff/sentence.js", "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/src/diff/css.js", "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/src/diff/json.js", "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/src/diff/array.js", "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/src/patch/parse.js", "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/src/util/distance-iterator.js", "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/src/patch/apply.js", "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/src/patch/create.js", "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/src/util/array.js", "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/src/patch/merge.js", "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/src/convert/dmp.js", "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/src/convert/xml.js", "../../node_modules/.pnpm/diff@4.0.2/node_modules/diff/src/index.js", "../../node_modules/.pnpm/uvu@0.1.0/node_modules/uvu/diff/index.js", "../../node_modules/.pnpm/uvu@0.1.0/node_modules/uvu/assert/index.js", "../../math.js", "../../node_modules/.pnpm/@modfy+estester-client@0.1.0/node_modules/@modfy/estester-client/src/client.tsx", "../../node_modules/.pnpm/@modfy+estester-client@0.1.0/node_modules/@modfy/estester-client/src/index.ts", "../../suites/modfy-tester/index.test.ts"],
  "sourcesContent": ["var has = Object.prototype.hasOwnProperty;\n\nmodule.exports = function dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n", "'use strict';\n\nlet FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY=true;\nif (typeof process !== 'undefined') {\n\t({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env);\n\tisTTY = process.stdout && process.stdout.isTTY;\n}\n\nconst $ = {\n\tenabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (\n\t\tFORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY\n\t),\n\n\t// modifiers\n\treset: init(0, 0),\n\tbold: init(1, 22),\n\tdim: init(2, 22),\n\titalic: init(3, 23),\n\tunderline: init(4, 24),\n\tinverse: init(7, 27),\n\thidden: init(8, 28),\n\tstrikethrough: init(9, 29),\n\n\t// colors\n\tblack: init(30, 39),\n\tred: init(31, 39),\n\tgreen: init(32, 39),\n\tyellow: init(33, 39),\n\tblue: init(34, 39),\n\tmagenta: init(35, 39),\n\tcyan: init(36, 39),\n\twhite: init(37, 39),\n\tgray: init(90, 39),\n\tgrey: init(90, 39),\n\n\t// background colors\n\tbgBlack: init(40, 49),\n\tbgRed: init(41, 49),\n\tbgGreen: init(42, 49),\n\tbgYellow: init(43, 49),\n\tbgBlue: init(44, 49),\n\tbgMagenta: init(45, 49),\n\tbgCyan: init(46, 49),\n\tbgWhite: init(47, 49)\n};\n\nfunction run(arr, str) {\n\tlet i=0, tmp, beg='', end='';\n\tfor (; i < arr.length; i++) {\n\t\ttmp = arr[i];\n\t\tbeg += tmp.open;\n\t\tend += tmp.close;\n\t\tif (!!~str.indexOf(tmp.close)) {\n\t\t\tstr = str.replace(tmp.rgx, tmp.close + tmp.open);\n\t\t}\n\t}\n\treturn beg + str + end;\n}\n\nfunction chain(has, keys) {\n\tlet ctx = { has, keys };\n\n\tctx.reset = $.reset.bind(ctx);\n\tctx.bold = $.bold.bind(ctx);\n\tctx.dim = $.dim.bind(ctx);\n\tctx.italic = $.italic.bind(ctx);\n\tctx.underline = $.underline.bind(ctx);\n\tctx.inverse = $.inverse.bind(ctx);\n\tctx.hidden = $.hidden.bind(ctx);\n\tctx.strikethrough = $.strikethrough.bind(ctx);\n\n\tctx.black = $.black.bind(ctx);\n\tctx.red = $.red.bind(ctx);\n\tctx.green = $.green.bind(ctx);\n\tctx.yellow = $.yellow.bind(ctx);\n\tctx.blue = $.blue.bind(ctx);\n\tctx.magenta = $.magenta.bind(ctx);\n\tctx.cyan = $.cyan.bind(ctx);\n\tctx.white = $.white.bind(ctx);\n\tctx.gray = $.gray.bind(ctx);\n\tctx.grey = $.grey.bind(ctx);\n\n\tctx.bgBlack = $.bgBlack.bind(ctx);\n\tctx.bgRed = $.bgRed.bind(ctx);\n\tctx.bgGreen = $.bgGreen.bind(ctx);\n\tctx.bgYellow = $.bgYellow.bind(ctx);\n\tctx.bgBlue = $.bgBlue.bind(ctx);\n\tctx.bgMagenta = $.bgMagenta.bind(ctx);\n\tctx.bgCyan = $.bgCyan.bind(ctx);\n\tctx.bgWhite = $.bgWhite.bind(ctx);\n\n\treturn ctx;\n}\n\nfunction init(open, close) {\n\tlet blk = {\n\t\topen: `\\x1b[${open}m`,\n\t\tclose: `\\x1b[${close}m`,\n\t\trgx: new RegExp(`\\\\x1b\\\\[${close}m`, 'g')\n\t};\n\treturn function (txt) {\n\t\tif (this !== void 0 && this.has !== void 0) {\n\t\t\t!!~this.has.indexOf(open) || (this.has.push(open),this.keys.push(blk));\n\t\t\treturn txt === void 0 ? this : $.enabled ? run(this.keys, txt+'') : txt+'';\n\t\t}\n\t\treturn txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt+'') : txt+'';\n\t};\n}\n\nmodule.exports = $;\n", "export default function Diff() {}\n\nDiff.prototype = {\n  diff(oldString, newString, options = {}) {\n    let callback = options.callback;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    this.options = options;\n\n    let self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function() { callback(undefined, value); }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    }\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n\n    let newLen = newString.length, oldLen = oldString.length;\n    let editLength = 1;\n    let maxEditLength = newLen + oldLen;\n    let bestPath = [{ newPos: -1, components: [] }];\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    let oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{value: this.join(newString), count: newString.length}]);\n    }\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (let diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        let basePath;\n        let addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        let canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n        // If we have hit the end of both strings, then we are done\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    }\n\n    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced.\n    if (callback) {\n      (function exec() {\n        setTimeout(function() {\n          // This should not happen, but we want to be safe.\n          /* istanbul ignore next */\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      }());\n    } else {\n      while (editLength <= maxEditLength) {\n        let ret = execEditLength();\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n\n  pushComponent(components, added, removed) {\n    let last = components[components.length - 1];\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };\n    } else {\n      components.push({count: 1, added: added, removed: removed });\n    }\n  },\n  extractCommon(basePath, newString, oldString, diagonalPath) {\n    let newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n\n        commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({count: commonCount});\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n\n  equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right\n        || (this.options.ignoreCase && left.toLowerCase() === right.toLowerCase());\n    }\n  },\n  removeEmpty(array) {\n    let ret = [];\n    for (let i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  },\n  castInput(value) {\n    return value;\n  },\n  tokenize(value) {\n    return value.split('');\n  },\n  join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  let componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    let component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        let value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function(value, i) {\n          let oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n      newPos += component.count;\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count;\n\n      // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n      if (componentPos && components[componentPos - 1].added) {\n        let tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  }\n\n  // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n  let lastComponent = components[componentLen - 1];\n  if (componentLen > 1\n      && typeof lastComponent.value === 'string'\n      && (lastComponent.added || lastComponent.removed)\n      && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return { newPos: path.newPos, components: path.components.slice(0) };\n}\n", "import Diff from './base';\n\nexport const characterDiff = new Diff();\nexport function diffChars(oldStr, newStr, options) { return characterDiff.diff(oldStr, newStr, options); }\n", "export function generateOptions(options, defaults) {\n  if (typeof options === 'function') {\n    defaults.callback = options;\n  } else if (options) {\n    for (let name in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(name)) {\n        defaults[name] = options[name];\n      }\n    }\n  }\n  return defaults;\n}\n", "import Diff from './base';\nimport {generateOptions} from '../util/params';\n\n// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080\u201300FF\n//  - U+00D7  \u00D7 Multiplication sign\n//  - U+00F7  \u00F7 Division sign\n// Latin Extended-A, 0100\u2013017F\n// Latin Extended-B, 0180\u2013024F\n// IPA Extensions, 0250\u201302AF\n// Spacing Modifier Letters, 02B0\u201302FF\n//  - U+02C7  \u02C7 &#711;  Caron\n//  - U+02D8  \u02D8 &#728;  Breve\n//  - U+02D9  \u02D9 &#729;  Dot Above\n//  - U+02DA  \u02DA &#730;  Ring Above\n//  - U+02DB  \u02DB &#731;  Ogonek\n//  - U+02DC  \u02DC &#732;  Small Tilde\n//  - U+02DD  \u02DD &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00\u20131EFF\nconst extendedWordChars = /^[a-zA-Z\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}]+$/u;\n\nconst reWhitespace = /\\S/;\n\nexport const wordDiff = new Diff();\nwordDiff.equals = function(left, right) {\n  if (this.options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n  return left === right || (this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right));\n};\nwordDiff.tokenize = function(value) {\n  let tokens = value.split(/(\\s+|[()[\\]{}'\"]|\\b)/);\n\n  // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n  for (let i = 0; i < tokens.length - 1; i++) {\n    // If we have an empty string in the next field and we have only word chars before and after, merge\n    if (!tokens[i + 1] && tokens[i + 2]\n          && extendedWordChars.test(tokens[i])\n          && extendedWordChars.test(tokens[i + 2])) {\n      tokens[i] += tokens[i + 2];\n      tokens.splice(i + 1, 2);\n      i--;\n    }\n  }\n\n  return tokens;\n};\n\nexport function diffWords(oldStr, newStr, options) {\n  options = generateOptions(options, {ignoreWhitespace: true});\n  return wordDiff.diff(oldStr, newStr, options);\n}\n\nexport function diffWordsWithSpace(oldStr, newStr, options) {\n  return wordDiff.diff(oldStr, newStr, options);\n}\n", "import Diff from './base';\nimport {generateOptions} from '../util/params';\n\nexport const lineDiff = new Diff();\nlineDiff.tokenize = function(value) {\n  let retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n  // Ignore the final empty token that occurs if the string ends with a new line\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  }\n\n  // Merge the content and line separators into single tokens\n  for (let i = 0; i < linesAndNewlines.length; i++) {\n    let line = linesAndNewlines[i];\n\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nexport function diffLines(oldStr, newStr, callback) { return lineDiff.diff(oldStr, newStr, callback); }\nexport function diffTrimmedLines(oldStr, newStr, callback) {\n  let options = generateOptions(callback, {ignoreWhitespace: true});\n  return lineDiff.diff(oldStr, newStr, options);\n}\n", "import Diff from './base';\n\n\nexport const sentenceDiff = new Diff();\nsentenceDiff.tokenize = function(value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\n\nexport function diffSentences(oldStr, newStr, callback) { return sentenceDiff.diff(oldStr, newStr, callback); }\n", "import Diff from './base';\n\nexport const cssDiff = new Diff();\ncssDiff.tokenize = function(value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\n\nexport function diffCss(oldStr, newStr, callback) { return cssDiff.diff(oldStr, newStr, callback); }\n", "import Diff from './base';\nimport {lineDiff} from './line';\n\nconst objectPrototypeToString = Object.prototype.toString;\n\n\nexport const jsonDiff = new Diff();\n// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\njsonDiff.useLongestToken = true;\n\njsonDiff.tokenize = lineDiff.tokenize;\njsonDiff.castInput = function(value) {\n  const {undefinedReplacement, stringifyReplacer = (k, v) => typeof v === 'undefined' ? undefinedReplacement : v} = this.options;\n\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\njsonDiff.equals = function(left, right) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n};\n\nexport function diffJson(oldObj, newObj, options) { return jsonDiff.diff(oldObj, newObj, options); }\n\n// This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\nexport function canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  let i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  let canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (typeof obj === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n    let sortedKeys = [],\n        key;\n    for (key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(key)) {\n        sortedKeys.push(key);\n      }\n    }\n    sortedKeys.sort();\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      key = sortedKeys[i];\n      canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack, replacer, key);\n    }\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n  return canonicalizedObj;\n}\n", "import Diff from './base';\n\nexport const arrayDiff = new Diff();\narrayDiff.tokenize = function(value) {\n  return value.slice();\n};\narrayDiff.join = arrayDiff.removeEmpty = function(value) {\n  return value;\n};\n\nexport function diffArrays(oldArr, newArr, callback) { return arrayDiff.diff(oldArr, newArr, callback); }\n", "export function parsePatch(uniDiff, options = {}) {\n  let diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    let index = {};\n    list.push(index);\n\n    // Parse diff metadata\n    while (i < diffstr.length) {\n      let line = diffstr[i];\n\n      // File header found, end parsing diff metadata\n      if ((/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/).test(line)) {\n        break;\n      }\n\n      // Diff index\n      let header = (/^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/).exec(line);\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    }\n\n    // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n    parseFileHeader(index);\n    parseFileHeader(index);\n\n    // Parse hunks\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      let line = diffstr[i];\n\n      if ((/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/).test(line)) {\n        break;\n      } else if ((/^@@/).test(line)) {\n        index.hunks.push(parseHunk());\n      } else if (line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(line));\n      } else {\n        i++;\n      }\n    }\n  }\n\n  // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n  function parseFileHeader(index) {\n    const fileHeader = (/^(---|\\+\\+\\+)\\s+(.*)$/).exec(diffstr[i]);\n    if (fileHeader) {\n      let keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      const data = fileHeader[2].split('\\t', 2);\n      let fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n      if ((/^\".*\"$/).test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n\n      i++;\n    }\n  }\n\n  // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n  function parseHunk() {\n    let chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n\n    let hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: +chunkHeader[2] || 1,\n      newStart: +chunkHeader[3],\n      newLines: +chunkHeader[4] || 1,\n      lines: [],\n      linedelimiters: []\n    };\n\n    let addCount = 0,\n        removeCount = 0;\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0\n            && (i + 2 < diffstr.length)\n            && diffstr[i + 1].indexOf('+++ ') === 0\n            && diffstr[i + 2].indexOf('@@') === 0) {\n          break;\n      }\n      let operation = (diffstr[i].length == 0 && i != (diffstr.length - 1)) ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    }\n\n    // Handle the empty block count case\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    }\n\n    // Perform optional sanity checking\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n", "// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nexport default function(start, minLine, maxLine) {\n  let wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      }\n\n      // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      }\n\n      // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    }\n\n    // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n  };\n}\n", "import {parsePatch} from './parse';\nimport distanceIterator from '../util/distance-iterator';\n\nexport function applyPatch(source, uniDiff, options = {}) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  }\n\n  // Apply the diff to the input\n  let lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n\n      compareLine = options.compareLine || ((lineNumber, line, operation, patchContent) => line === patchContent),\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n\n      removeEOFNL,\n      addEOFNL;\n\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n  function hunkFits(hunk, toPos) {\n    for (let j = 0; j < hunk.lines.length; j++) {\n      let line = hunk.lines[j],\n          operation = (line.length > 0 ? line[0] : ' '),\n          content = (line.length > 0 ? line.substr(1) : line);\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n        toPos++;\n      }\n    }\n\n    return true;\n  }\n\n  // Search best fit offsets for each hunk based on the previous ones\n  for (let i = 0; i < hunks.length; i++) {\n    let hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n\n    let iterator = distanceIterator(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    }\n\n    // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  }\n\n  // Apply patch hunks\n  let diffOffset = 0;\n  for (let i = 0; i < hunks.length; i++) {\n    let hunk = hunks[i],\n        toPos = hunk.oldStart + hunk.offset + diffOffset - 1;\n    diffOffset += hunk.newLines - hunk.oldLines;\n\n    if (toPos < 0) { // Creating a new file\n      toPos = 0;\n    }\n\n    for (let j = 0; j < hunk.lines.length; j++) {\n      let line = hunk.lines[j],\n          operation = (line.length > 0 ? line[0] : ' '),\n          content = (line.length > 0 ? line.substr(1) : line),\n          delimiter = hunk.linedelimiters[j];\n\n      if (operation === ' ') {\n        toPos++;\n      } else if (operation === '-') {\n        lines.splice(toPos, 1);\n        delimiters.splice(toPos, 1);\n      /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(toPos, 0, content);\n        delimiters.splice(toPos, 0, delimiter);\n        toPos++;\n      } else if (operation === '\\\\') {\n        let previousOperation = hunk.lines[j - 1] ? hunk.lines[j - 1][0] : null;\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  }\n\n  // Handle EOFNL insertion/removal\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n  for (let _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n  return lines.join('');\n}\n\n// Wrapper that supports multiple file patches via callbacks.\nexport function applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  let currentIndex = 0;\n  function processIndex() {\n    let index = uniDiff[currentIndex++];\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function(err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      let updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function(err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n  processIndex();\n}\n", "import {diffLines} from '../diff/line';\n\nexport function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  const diff = diffLines(oldStr, newStr, options);\n  diff.push({value: '', lines: []}); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function(entry) { return ' ' + entry; });\n  }\n\n  let hunks = [];\n  let oldRangeStart = 0, newRangeStart = 0, curRange = [],\n      oldLine = 1, newLine = 1;\n  for (let i = 0; i < diff.length; i++) {\n    const current = diff[i],\n          lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      // If we have previous context, start with that\n      if (!oldRangeStart) {\n        const prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      }\n\n      // Output our changes\n      curRange.push(... lines.map(function(entry) {\n        return (current.added ? '+' : '-') + entry;\n      }));\n\n      // Track the updated file position\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          // Overlapping\n          curRange.push(... contextLines(lines));\n        } else {\n          // end the range and output\n          let contextSize = Math.min(lines.length, options.context);\n          curRange.push(... contextLines(lines.slice(0, contextSize)));\n\n          let hunk = {\n            oldStart: oldRangeStart,\n            oldLines: (oldLine - oldRangeStart + contextSize),\n            newStart: newRangeStart,\n            newLines: (newLine - newRangeStart + contextSize),\n            lines: curRange\n          };\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            let oldEOFNewline = ((/\\n$/).test(oldStr));\n            let newEOFNewline = ((/\\n$/).test(newStr));\n            let noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n            if (!oldEOFNewline && noNlBeforeAdds) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            }\n            if ((!oldEOFNewline && !noNlBeforeAdds) || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n          hunks.push(hunk);\n\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  }\n\n  return {\n    oldFileName: oldFileName, newFileName: newFileName,\n    oldHeader: oldHeader, newHeader: newHeader,\n    hunks: hunks\n  };\n}\n\nexport function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  const diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);\n\n  const ret = [];\n  if (oldFileName == newFileName) {\n    ret.push('Index: ' + oldFileName);\n  }\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (let i = 0; i < diff.hunks.length; i++) {\n    const hunk = diff.hunks[i];\n    ret.push(\n      '@@ -' + hunk.oldStart + ',' + hunk.oldLines\n      + ' +' + hunk.newStart + ',' + hunk.newLines\n      + ' @@'\n    );\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\n\nexport function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n", "export function arrayEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return arrayStartsWith(a, b);\n}\n\nexport function arrayStartsWith(array, start) {\n  if (start.length > array.length) {\n    return false;\n  }\n\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== array[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import {structuredPatch} from './create';\nimport {parsePatch} from './parse';\n\nimport {arrayEqual, arrayStartsWith} from '../util/array';\n\nexport function calcLineCount(hunk) {\n  const {oldLines, newLines} = calcOldNewLineCount(hunk.lines);\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\n\nexport function merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n\n  let ret = {};\n\n  // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n\n  let mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    let mineCurrent = mine.hunks[mineIndex] || {oldStart: Infinity},\n        theirsCurrent = theirs.hunks[theirsIndex] || {oldStart: Infinity};\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      let mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if ((/^@@/m).test(param) || ((/^Index:/m).test(param))) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {mine, theirs};\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart\n    && (test.oldStart + test.oldLines) < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart, oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset, newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  let mine = {offset: mineOffset, lines: mineLines, index: 0},\n      their = {offset: theirOffset, lines: theirLines, index: 0};\n\n  // Handle any leading content\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine);\n\n  // Now in the overlap content. Scan through and select the best changes from each.\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    let mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+')\n        && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      // Mine inserted\n      hunk.lines.push(... collectChange(mine));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      // Theirs inserted\n      hunk.lines.push(... collectChange(their));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  }\n\n  // Now push anything that may be remaining\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  let myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges)\n        && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      hunk.lines.push(... myChanges);\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges)\n        && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      hunk.lines.push(... theirChanges);\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    hunk.lines.push(... myChanges);\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  let myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n  if (theirChanges.merged) {\n    hunk.lines.push(... theirChanges.merged);\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    let line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    let line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  let ret = [],\n      operation = state.lines[state.index][0];\n  while (state.index < state.lines.length) {\n    let line = state.lines[state.index];\n\n    // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\nfunction collectContext(state, matchChanges) {\n  let changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n  while (matchIndex < matchChanges.length\n        && state.index < state.lines.length) {\n    let change = state.lines[state.index],\n        match = matchChanges[matchIndex];\n\n    // Once we've hit our add, then we are done\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n\n    merged.push(match);\n    matchIndex++;\n\n    // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+'\n      && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged,\n    changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function(prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (let i = 0; i < delta; i++) {\n    let changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  let oldLines = 0;\n  let newLines = 0;\n\n  lines.forEach(function(line) {\n    if (typeof line !== 'string') {\n      let myCount = calcOldNewLineCount(line.mine);\n      let theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n\n  return {oldLines, newLines};\n}\n", "// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nexport function convertChangesToDMP(changes) {\n  let ret = [],\n      change,\n      operation;\n  for (let i = 0; i < changes.length; i++) {\n    change = changes[i];\n    if (change.added) {\n      operation = 1;\n    } else if (change.removed) {\n      operation = -1;\n    } else {\n      operation = 0;\n    }\n\n    ret.push([operation, change.value]);\n  }\n  return ret;\n}\n", "export function convertChangesToXML(changes) {\n  let ret = [];\n  for (let i = 0; i < changes.length; i++) {\n    let change = changes[i];\n    if (change.added) {\n      ret.push('<ins>');\n    } else if (change.removed) {\n      ret.push('<del>');\n    }\n\n    ret.push(escapeHTML(change.value));\n\n    if (change.added) {\n      ret.push('</ins>');\n    } else if (change.removed) {\n      ret.push('</del>');\n    }\n  }\n  return ret.join('');\n}\n\nfunction escapeHTML(s) {\n  let n = s;\n  n = n.replace(/&/g, '&amp;');\n  n = n.replace(/</g, '&lt;');\n  n = n.replace(/>/g, '&gt;');\n  n = n.replace(/\"/g, '&quot;');\n\n  return n;\n}\n", "/* See LICENSE file for terms of use */\n\n/*\n * Text diff implementation.\n *\n * This library supports the following APIS:\n * JsDiff.diffChars: Character by character diff\n * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\n * JsDiff.diffLines: Line based diff\n *\n * JsDiff.diffCss: Diff targeted at CSS content\n *\n * These methods are based on the implementation proposed in\n * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\n */\nimport Diff from './diff/base';\nimport {diffChars} from './diff/character';\nimport {diffWords, diffWordsWithSpace} from './diff/word';\nimport {diffLines, diffTrimmedLines} from './diff/line';\nimport {diffSentences} from './diff/sentence';\n\nimport {diffCss} from './diff/css';\nimport {diffJson, canonicalize} from './diff/json';\n\nimport {diffArrays} from './diff/array';\n\nimport {applyPatch, applyPatches} from './patch/apply';\nimport {parsePatch} from './patch/parse';\nimport {merge} from './patch/merge';\nimport {structuredPatch, createTwoFilesPatch, createPatch} from './patch/create';\n\nimport {convertChangesToDMP} from './convert/dmp';\nimport {convertChangesToXML} from './convert/xml';\n\nexport {\n  Diff,\n\n  diffChars,\n  diffWords,\n  diffWordsWithSpace,\n  diffLines,\n  diffTrimmedLines,\n  diffSentences,\n\n  diffCss,\n  diffJson,\n\n  diffArrays,\n\n  structuredPatch,\n  createTwoFilesPatch,\n  createPatch,\n  applyPatch,\n  applyPatches,\n  parsePatch,\n  merge,\n  convertChangesToDMP,\n  convertChangesToXML,\n  canonicalize\n};\n", "const kleur = require('kleur');\nconst diff = require('diff');\n\nconst colors = {\n\t'--': kleur.red,\n\t'\u00B7\u00B7': kleur.grey,\n\t'++': kleur.green,\n};\n\nconst TITLE = kleur.dim().italic;\nconst TAB=kleur.dim('\u2192'), SPACE=kleur.dim('\u00B7'), NL=kleur.dim('\u21B5');\nconst LOG = (sym, str) => colors[sym](sym + PRETTY(str)) + '\\n';\nconst LINE = (num, x) => kleur.dim('L' + String(num).padStart(x, '0') + ' ');\nconst PRETTY = str => str.replace(/[ ]/g, SPACE).replace(/\\t/g, TAB).replace(/(\\r?\\n)/g, NL);\n\nfunction line(obj, prev, pad) {\n\tlet char = obj.removed ? '--' : obj.added ? '++' : '\u00B7\u00B7';\n\tlet arr = obj.value.replace(/\\r?\\n$/, '').split('\\n');\n\tlet i=0, tmp, out='';\n\n\tif (obj.added) out += colors[char]().underline(TITLE('Expected:')) + '\\n';\n\telse if (obj.removed) out += colors[char]().underline(TITLE('Actual:')) + '\\n';\n\n\tfor (; i < arr.length; i++) {\n\t\ttmp = arr[i];\n\t\tif (tmp != null) {\n\t\t\tif (prev) out += LINE(prev + i, pad);\n\t\t\tout += LOG(char, tmp || '\\n');\n\t\t}\n\t}\n\n\treturn out;\n}\n\n// TODO: want better diffing\n//~> complex items bail outright\nfunction arrays(input, expect) {\n\tlet arr = diff.diffArrays(input, expect);\n\tlet i=0, j=0, k=0, tmp, val, char;\n\tlet out = LOG('\u00B7\u00B7', '[');\n\n\tfor (; i < arr.length; i++) {\n\t\tchar = (tmp = arr[i]).removed ? '--' : tmp.added ? '++' : '\u00B7\u00B7';\n\n\t\tif (tmp.added) {\n\t\t\tout += colors[char]().underline(TITLE('Expected:')) + '\\n';\n\t\t} else if (tmp.removed) {\n\t\t\tout += colors[char]().underline(TITLE('Actual:')) + '\\n';\n\t\t}\n\n\t\tfor (j=0; j < tmp.value.length; j++) {\n\t\t\tval = JSON.stringify(tmp.value[j], null, 2).split(/\\r?\\n/g);\n\t\t\tfor (k=0; k < val.length; k++) out += LOG(char, '  ' + val[k] + (/^[{}]$/.test(val[k]) ? '' : ','));\n\t\t}\n\t}\n\n\treturn out + LOG('\u00B7\u00B7', ']');\n}\n\nfunction lines(input, expect, linenum = 0) {\n\tlet i=0, tmp, output='';\n\tlet arr = diff.diffLines(input, expect);\n\tlet pad = String(expect.split(/\\r?\\n/g).length - linenum).length;\n\n\tfor (; i < arr.length; i++) {\n\t\toutput += line(tmp = arr[i], linenum, pad);\n\t\tif (linenum && !tmp.removed) linenum += tmp.count;\n\t}\n\n\treturn output;\n}\n\nfunction chars(input, expect) {\n\tlet arr = diff.diffChars(input, expect);\n\tlet i=0, output='', tmp;\n\n\tlet l1 = input.length;\n\tlet l2 = expect.length;\n\n\tlet p1 = PRETTY(input);\n\tlet p2 = PRETTY(expect);\n\n\ttmp = arr[i];\n\n\tif (l1 === l2) {\n\t\t// no length offsets\n\t} else if (tmp.removed) {\n\t\tlet del = tmp.count - arr[i + 1].count;\n\t\tif (del == 0) {\n\t\t\t// wash~\n\t\t} else if (del > 0) {\n\t\t\texpect = ' '.repeat(del) + expect;\n\t\t\tp2 = ' '.repeat(del) + p2;\n\t\t\tl2 += del;\n\t\t} else if (del < 0) {\n\t\t\tinput = ' '.repeat(-del) + input;\n\t\t\tp1 = ' '.repeat(-del) + p1;\n\t\t\tl1 += -del;\n\t\t}\n\t}\n\n\toutput += direct(p1, p2, l1, l2);\n\n\tif (l1 === l2) {\n\t\tfor (tmp='  '; i < l1; i++) {\n\t\t\ttmp += input[i] === expect[i] ? ' ' : '^';\n\t\t}\n\t} else {\n\t\tfor (tmp='  '; i < arr.length; i++) {\n\t\t\ttmp += ((arr[i].added || arr[i].removed) ? '^' : ' ').repeat(Math.max(arr[i].count, 0));\n\t\t\tif (i + 1 < arr.length && ((arr[i].added && arr[i+1].removed) || (arr[i].removed && arr[i+1].added))) {\n\t\t\t\tarr[i + 1].count -= arr[i].count;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output + kleur.red(tmp);\n}\n\nfunction direct(input, expect, lenA = String(input).length, lenB = String(expect).length) {\n\tlet gutter = 4;\n\tlet lenC = Math.max(lenA, lenB);\n\tlet typeA=typeof input, typeB=typeof expect;\n\n\tif (typeA !== typeB) {\n\t\tgutter = 2;\n\n\t\tlet delA = gutter + lenC - lenA;\n\t\tlet delB = gutter + lenC - lenB;\n\n\t\tinput += ' '.repeat(delA) + kleur.dim(`[${typeA}]`);\n\t\texpect += ' '.repeat(delB) + kleur.dim(`[${typeB}]`);\n\n\t\tlenA += delA + typeA.length + 2;\n\t\tlenB += delB + typeB.length + 2;\n\t\tlenC = Math.max(lenA, lenB);\n\t}\n\n\tlet output = colors['++']('++' + expect + ' '.repeat(gutter + lenC - lenB) + TITLE('(Expected)')) + '\\n';\n\treturn output + colors['--']('--' + input + ' '.repeat(gutter + lenC - lenA) + TITLE('(Actual)')) + '\\n';\n}\n\nfunction sort(input, expect) {\n\tvar k, i=0, tmp, isArr = Array.isArray(input);\n\tvar keys=[], out=isArr ? Array(input.length) : {};\n\n\tif (isArr) {\n\t\tfor (i=0; i < out.length; i++) {\n\t\t\ttmp = input[i];\n\t\t\tif (!tmp || typeof tmp !== 'object') out[i] = tmp;\n\t\t\telse out[i] = sort(tmp, expect[i]); // might not be right\n\t\t}\n\t} else {\n\t\tfor (k in expect)\n\t\t\tkeys.push(k);\n\n\t\tfor (; i < keys.length; i++) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(input, k = keys[i])) {\n\t\t\t\tif (!(tmp = input[k]) || typeof tmp !== 'object') out[k] = tmp;\n\t\t\t\telse out[k] = sort(tmp, expect[k]);\n\t\t\t}\n\t\t}\n\n\t\tfor (k in input) {\n\t\t\tif (!out.hasOwnProperty(k)) {\n\t\t\t\tout[k] = input[k]; // expect didnt have\n\t\t\t}\n\t\t}\n\t}\n\n\treturn out;\n}\n\nfunction circular() {\n\tvar cache = new Set;\n\treturn function print(key, val) {\n\t\tif (!val || typeof val !== 'object') return val;\n\t\tif (cache.has(val)) return '[Circular]';\n\t\tcache.add(val); return val;\n\t}\n}\n\nfunction compare(input, expect) {\n\tif (Array.isArray(expect)) return arrays(input, expect);\n\tif (expect instanceof RegExp) return chars(''+input, ''+expect);\n\n\tif (expect && typeof expect == 'object') {\n\t\tinput = JSON.stringify(sort(input, expect), circular(), 2);\n\t\texpect = JSON.stringify(expect, circular(), 2);\n\t}\n\n\tif (/\\r?\\n/.test(String(expect))) {\n\t\treturn lines(input, expect);\n\t}\n\n\tif (typeof expect == 'string') {\n\t\treturn chars(input, expect);\n\t}\n\n\treturn direct(input, expect);\n}\n\nexports.arrays = arrays;\nexports.chars = chars;\nexports.circular = circular;\nexports.compare = compare;\nexports.direct = direct;\nexports.lines = lines;\nexports.sort = sort;", "const dequal = require('dequal');\nconst { compare, direct, lines } = require('uvu/diff');\n\nfunction dedent(str) {\n\tlet arr = str.match(/^[ \\t]*(?=\\S)/gm);\n\tlet min = !!arr && Math.min(...arr.map(x => x.length));\n\treturn (!arr || !min) ? str : str.replace(new RegExp(`^[ \\\\t]{${min}}`, 'gm'), '');\n}\n\nclass Assertion extends Error {\n\tconstructor(opts={}) {\n\t\tsuper(opts.message);\n\t\tthis.name = 'Assertion';\n\t\tthis.code = 'ERR_ASSERTION';\n\t\tif (Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, this.constructor);\n\t\t}\n\t\tthis.details = opts.details || false;\n\t\tthis.generated = !!opts.generated;\n\t\tthis.operator = opts.operator;\n\t\tthis.expects = opts.expects;\n\t\tthis.actual = opts.actual;\n\t}\n}\n\nfunction assert(bool, actual, expects, operator, detailer, backup, msg) {\n\tif (bool) return;\n\tlet message = msg || backup;\n\tif (msg instanceof Error) throw msg;\n\tlet details = detailer && detailer(actual, expects);\n\tthrow new Assertion({ actual, expects, operator, message, details, generated: !msg });\n}\n\nfunction ok(val, msg) {\n\tassert(!!val, false, true, 'ok', false, 'Expected value to be truthy', msg);\n}\n\nfunction is(val, exp, msg) {\n\tassert(val === exp, val, exp, 'is', direct, 'Expected values to be strictly equal:', msg);\n}\n\nfunction equal(val, exp, msg) {\n\tassert(dequal(val, exp), val, exp, 'equal', compare, 'Expected values to be deeply equal:', msg);\n}\n\nfunction unreachable(msg) {\n\tassert(false, true, false, 'unreachable', false, 'Expected not to be reached!', msg);\n}\n\nfunction type(val, exp, msg) {\n\tlet tmp = typeof val;\n\tassert(tmp === exp, tmp, exp, 'type', false, `Expected \"${tmp}\" to be \"${exp}\"`, msg);\n}\n\nfunction instance(val, exp, msg) {\n\tlet name = '`' + (exp.name || exp.constructor.name) + '`';\n\tassert(val instanceof exp, val, exp, 'instance', false, `Expected value to be an instance of ${name}`, msg);\n}\n\nfunction snapshot(val, exp, msg) {\n\tval=dedent(val); exp=dedent(exp);\n\tassert(val === exp, val, exp, 'snapshot', lines, 'Expected value to match snapshot:', msg);\n}\n\nconst lineNums = (x, y) => lines(x, y, 1);\nfunction fixture(val, exp, msg) {\n\tval=dedent(val); exp=dedent(exp);\n\tassert(val === exp, val, exp, 'fixture', lineNums, 'Expected value to match fixture:', msg);\n}\n\nfunction throws(blk, exp, msg) {\n\tif (!msg && typeof exp === 'string') {\n\t\tmsg = exp; exp = null;\n\t}\n\n\ttry {\n\t\tblk();\n\t\tassert(false, false, true, 'throws', direct, 'Expected function to throw', msg);\n\t} catch (err) {\n\t\tif (err instanceof Assertion) throw err;\n\n\t\tif (typeof exp === 'function') {\n\t\t\tassert(exp(err), false, true, 'throws', false, 'Expected function to throw matching exception', msg);\n\t\t} else if (exp instanceof RegExp) {\n\t\t\tlet tmp = '`' + String(exp) + '`';\n\t\t\tassert(exp.test(err.message), false, true, 'throws', false, `Expected function to throw exception matching ${tmp} pattern`, msg);\n\t\t}\n\t}\n}\n\n// ---\n\nfunction not(val, msg) {\n\tassert(!val, true, false, 'not', false, 'Expected value to be falsey', msg);\n}\n\nnot.ok = not;\n\nis.not = function (val, exp, msg) {\n\tassert(val !== exp, val, exp, 'is.not', false, 'Expected values not to be strictly equal', msg);\n}\n\nnot.equal = function (val, exp, msg) {\n\tassert(!dequal(val, exp), val, exp, 'not.equal', false, 'Expected values not to be deeply equal', msg);\n}\n\nnot.type = function (val, exp, msg) {\n\tlet tmp = typeof val;\n\tassert(tmp !== exp, tmp, exp, 'not.type', false, `Expected \"${tmp}\" not to be \"${exp}\"`, msg);\n}\n\nnot.instance = function (val, exp, msg) {\n\tlet name = '`' + (exp.name || exp.constructor.name) + '`';\n\tassert(!(val instanceof exp), val, exp, 'not.instance', false, `Expected value not to be an instance of ${name}`, msg);\n}\n\nnot.snapshot = function (val, exp, msg) {\n\tval=dedent(val); exp=dedent(exp);\n\tassert(val !== exp, val, exp, 'not.snapshot', false, 'Expected value not to match snapshot', msg);\n}\n\nnot.fixture = function (val, exp, msg) {\n\tval=dedent(val); exp=dedent(exp);\n\tassert(val !== exp, val, exp, 'not.fixture', false, 'Expected value not to match fixture', msg);\n}\n\nnot.throws = function (blk, exp, msg) {\n\tif (!msg && typeof exp === 'string') {\n\t\tmsg = exp; exp = null;\n\t}\n\n\ttry {\n\t\tblk();\n\t} catch (err) {\n\t\tif (typeof exp === 'function') {\n\t\t\tassert(!exp(err), true, false, 'not.throws', false, 'Expected function not to throw matching exception', msg);\n\t\t} else if (exp instanceof RegExp) {\n\t\t\tlet tmp = '`' + String(exp) + '`';\n\t\t\tassert(!exp.test(err.message), true, false, 'not.throws', false, `Expected function not to throw exception matching ${tmp} pattern`, msg);\n\t\t} else if (!exp) {\n\t\t\tassert(false, true, false, 'not.throws', false, 'Expected function not to throw', msg);\n\t\t}\n\t}\n}\n\nexports.Assertion = Assertion;\nexports.equal = equal;\nexports.fixture = fixture;\nexports.instance = instance;\nexports.is = is;\nexports.not = not;\nexports.ok = ok;\nexports.snapshot = snapshot;\nexports.throws = throws;\nexports.type = type;\nexports.unreachable = unreachable;", "exports.sum = (a, b) => a + b;\nexports.div = (a, b) => a / b;\nexports.mod = (a, b) => a % b;\n", "import {\n  BrowserTestGroupReturn,\n  RunTestInBrowserType,\n  TestGroupDebugMessage\n} from './types'\n\nexport const relayTestResults = async (data: BrowserTestGroupReturn) => {\n  // Will relayTestResults to logging server\n  console.log(JSON.stringify(data))\n  await fetch('http://localhost:8080/log', {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(data)\n  })\n  console.log('Sent log!')\n}\n\nexport const sendDebugMsg = async (testName: string, debugMsg: string) => {\n  const data: TestGroupDebugMessage = {\n    debugMsg,\n    testName,\n    debug: true\n  }\n  await fetch('http://localhost:8080/log', {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(data)\n  })\n}\n\nexport const runTestInBrowser: RunTestInBrowserType = async (\n  groupName,\n  tests,\n  testSelectors\n) => {\n  /**\n   * Test runner\n   */\n  const runTest = async () => {\n    const testGroupResult: BrowserTestGroupReturn = {\n      passed: 0,\n      failed: 0,\n      total: 0,\n      errors: [],\n      testName: groupName\n    }\n\n    document.title = `\uD83E\uDDEA ${groupName}`\n    console.log(`\uD83E\uDDEA Running test group: ${groupName}`)\n\n    try {\n      const beforeAllResult =\n        (await (tests.beforeAll && tests.beforeAll())) || undefined\n\n      const afterAll = tests.afterAll\n      const beforeEach = tests.beforeEach\n      const afterEach = tests.afterEach\n\n      // TODO: Promise.all?\n      for (const [name, test] of Object.entries(tests)) {\n        if (name === 'beforeAll' || name === 'afterAll') {\n          continue\n        }\n\n        // if selectors have been passed check if this test has been selected if not continue\n        if (testSelectors) {\n          if (!testSelectors[`${groupName}.${name}`]) continue\n        }\n\n        const beforeEachResult = beforeEach ? await beforeEach() : undefined\n\n        testGroupResult.total++\n        // console.log(`\uD83D\uDD03 Running test: ${name}`)\n        try {\n          console.log(`\u23F0 Running: ${name}`)\n          if (test) await test({ ...beforeAllResult, ...beforeEachResult })\n          testGroupResult.passed++\n          console.log(`\u2705 Test passed: ${name}`)\n        } catch (err) {\n          console.log(`\u274C Test failed: ${name}`)\n          const errorMessage =\n            `Error in test '${name}': ` + JSON.stringify((err as Error).message)\n          testGroupResult.errors.push(errorMessage)\n          testGroupResult.failed++\n          console.error(err)\n        }\n\n        if (afterEach)\n          await afterEach({ ...beforeAllResult, ...beforeEachResult })\n      }\n\n      if (afterAll) await afterAll({ ...beforeAllResult })\n\n      await relayTestResults(testGroupResult)\n    } catch (err) {\n      testGroupResult.errors.push(JSON.stringify((err as Error).message))\n      testGroupResult.failed++\n      console.error(err)\n      await relayTestResults(testGroupResult)\n    }\n  }\n  await runTest()\n  window.close()\n}\n", "import {\n  ParsedTestSelectors,\n  RunTestGroupType,\n  TestGroupReturn,\n  TestManifest,\n  TestOptions\n} from './types'\n\n/**\n * Runs a group of test with the selector (if provided)\n */\nexport const runTestGroup: RunTestGroupType = async (\n  groupName,\n  tests,\n  testSelectors,\n  exit\n) => {\n  const testGroupResult = {\n    passed: 0,\n    failed: 0,\n    total: 0\n  }\n\n  console.log(`\uD83E\uDDEA Running test group: ${groupName}`)\n\n  const beforeAllResult =\n    (await (tests.beforeAll && tests.beforeAll())) || undefined\n\n  const beforeEach = tests.beforeEach\n  const afterEach = tests.afterEach\n\n  const afterAll = tests.afterAll\n\n  // TODO: Promise.all?\n  for (const [name, test] of Object.entries(tests)) {\n    if (name === 'beforeAll') {\n      continue\n    }\n\n    // if selectors have been passed check if this test has been selected if not continue\n    if (testSelectors) {\n      if (!testSelectors[`${groupName}.${name}`]) continue\n    }\n\n    const beforeEachResult = beforeEach ? await beforeEach() : undefined\n\n    testGroupResult.total++\n    console.log(`\uD83C\uDFC3\u200D\u2642\uFE0F Running test: ${name}`)\n    try {\n      if (test) await test({ ...beforeAllResult, ...beforeEachResult })\n      testGroupResult.passed++\n      console.log(`\u2705 Test passed: ${name}`)\n    } catch (err) {\n      console.log(`\u274C Test failed: ${name}`)\n      console.error(err)\n      testGroupResult.failed++\n    }\n\n    if (afterEach) afterEach({ ...beforeAllResult, ...beforeEachResult })\n  }\n\n  if (afterAll) afterAll({ ...beforeAllResult })\n\n  if (exit) {\n    if (testGroupResult.failed > 0) {\n      process.exit(1)\n    }\n    process.exit(0)\n  }\n\n  return testGroupResult\n}\n\nexport const verifyGroups = (results: TestGroupReturn[]) => {\n  for (const result of results) {\n    if (result.failed > 0) {\n      process.exit(1)\n    }\n  }\n}\n\nexport const runTests = async (\n  testManifest: TestManifest,\n  options?: TestOptions\n) => {\n  const { name, groups } = testManifest\n\n  console.log(`\uD83D\uDE80 Running tests: ${name}`)\n\n  let testSelectors: ParsedTestSelectors = null\n  if (options?.tests) {\n    testSelectors = {}\n    options.tests.forEach((key) => {\n      // selectorsObject will be object as before the loop we're setting it as object, idk why ts doesn't pick that up\n      if (testSelectors) testSelectors[key] = null\n    })\n  }\n\n  for (const groupName of Object.keys(groups)) {\n    console.log(`Running test group: ${groupName}`)\n\n    const result = await runTestGroup(\n      groupName,\n      groups[groupName],\n      testSelectors\n    )\n\n    console.log(`Result for group: ${groupName}`)\n    console.log(\n      `\u2714 Passed: ${result.passed}, Failed: ${result.failed}, Total ${result.total}`\n    )\n  }\n\n  console.log(`\u2714 Finished tests: ${name}`)\n}\n\nexport * from './client'\n", "const assert = require('uvu/assert');\nconst math = require('../../math');\nconst { runTestGroup } = require('@modfy/estester-client')\n\nrunTestGroup(\"Basic bench\", {\n    'sum': () => {\n        assert.type(math.sum, 'function');\n        assert.is(math.sum(1, 2), 3);\n        assert.is(math.sum(-1, -2), -3);\n        assert.is(math.sum(-1, 1), 0);\n    },\n    'div': () => {\n        assert.type(math.div, 'function');\n        assert.is(math.div(1, 2), 0.5);\n        assert.is(math.div(-1, -2), 0.5);\n        assert.is(math.div(-1, 1), -1);\n    },\n    'mod': () => {\n        assert.type(math.mod, 'function');\n        assert.is(math.mod(1, 2), 1);\n        assert.is(math.mod(-3, -2), -1);\n        assert.is(math.mod(7, 4), 3);\n    }\n})\n"],
  "mappings": "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",
  "names": []
}
